/*
N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 
연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져있다.
우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안된다.
예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 
예를 들어, 아래와 같은 식을 만들 수 있다.
예를 들어 1+2+3-4*5/6 와 같은 식을 만들 수 있다.
식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 위 식의 결과는 나누기는 몫만 취한다. 

음수 나누기는 C++의 규칙을 따른다. 1+2+3-4*5/6 = 1
N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.*/#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;
int a[20], op[5], n, maxi = -2147000000, mini = 2147000000;
void DFS(int L, int res) {
	if (L == n) {
		if (res > maxi) maxi = res;
		if (res < mini) mini = res;
	}
	else {
		if (op[0] > 0) {
			op[0]--;
			DFS(L + 1, res + a[L]);
			op[0]++;
		}
		if (op[1] > 0) {
			op[1]--;
			DFS(L + 1, res - a[L]);
			op[1]++;
		}
		if (op[2] > 0) {
			op[2]--;
			DFS(L + 1, res*a[L]);
			op[2]++;
		}
		if (op[3] > 0) {
			op[3]--;
			DFS(L + 1, res / a[L]);
			op[3]++;
		}
	}
}


int main() {
	int i;
	scanf("%d", &n);
	for (i = 0; i < n; i++) {
		scanf("%d", &a[i]);
	}
	for (i = 0; i < 4; i++) {
		scanf("%d", &op[i]);
	}
	DFS(1, a[0]);
	printf("%d\n%d\n", maxi, mini);
	return 0;
}